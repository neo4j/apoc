import groovy.json.JsonOutput
import groovy.json.JsonSlurper

import java.security.MessageDigest

// Gets all Neo4j 5.0.0+ releases from Maven, ordered from oldest to most recent.
static def neo4jReleases() {
    def url = new URL("https://repo1.maven.org/maven2/org/neo4j/neo4j-kernel/")
    def htmlString = url.getText()
            .replace("<!DOCTYPE html>", "")
            .replace("<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">", "")

    def rootNode = new XmlParser().parseText(htmlString)
    def releases = initialiseNeo4jReleases()

    for (a in rootNode.body.main.pre.a) {
        def href = a.attributes()["href"]

        if (!href.contains("xml")) releases.add(href[0..-2])
    }

    return releases
            .findAll { it >= "5.0.0" }
            .sort { o1, o2 -> normalizeVersion(o1) <=> normalizeVersion(o2) }
            .reverse()
}

// In an ideal world this method would return an empty list. Alas, 5.0.0 was never published to mvn
static def initialiseNeo4jReleases() {
    return [ "5.0.0" ]
}

// Gets all APOC releases from Github
static def apocReleases() {
    def url = new URL("https://api.github.com/repos/neo4j/apoc/releases?page=1&per_page=500")
    def releases = new JsonSlurper().parseText(url.getText())
    return releases.findAll { !(it.prerelease || it.draft) }
}

// Any major.minor version of Neo4j should use the latest corresponding major.minor version of APOC
// E.g Neo4j 5.2.0 should find the APOC 5.2.x release with the largest patch (x value)
static def findApocVersion(apocReleases, neo4jRelease) {
    def majorNeoVersion = neo4jRelease.substring(0, 1)
    def minorNeoVersion = neo4jRelease.substring(2, 3)
    def candidates = apocReleases
            .findAll { it.substring(0, 1) == majorNeoVersion &&
                        it.substring(2,3) == minorNeoVersion
            }
            .sort { o1, o2 -> normalizeVersion(o1) <=> normalizeVersion(o2) }
    return candidates.size() > 0 ? candidates[-1] : null
}

// Calculates which APOC version should be used for each known Neo4j version.
task versions <<  {
    def neo4jReleases = neo4jReleases()
    def apocReleasesJSON = apocReleases()
    def apocReleases = apocReleasesJSON.collect { it.tag_name }
    def reader = new JsonSlurper();
    def checksums = reader.parse(new File("checksums.json"))
    def previousVersions = reader.parse(new File("versions.json"))
    def versions = []

    println(neo4jReleases)
    println(apocReleases)

    for (neo4jRelease in neo4jReleases) {
        def apocVersion = findApocVersion(apocReleases, neo4jRelease)

        if (apocVersion != null) {
            def url = apocReleasesJSON
                    .find { it.tag_name == apocVersion }
                    .assets.find { it.browser_download_url.contains("apoc-${apocVersion}") }
                    .browser_download_url

            def version = [
                    neo4j : neo4jRelease,
                    neo4jVersion : neo4jRelease,
                    apoc : apocVersion,
                    version: apocVersion,
                    url : "https://github.com/neo4j/apoc/releases/" + apocVersion,
                    homepageUrl : "https://github.com/neo4j/apoc/releases/" + apocVersion,
                    jar: url,
                    downloadUrl: url,
                    sha1: checksums[apocVersion].sha1,
                    sha256:  checksums[apocVersion].sha256,
                    md5:  checksums[apocVersion].md5,
                    config: [ "+:dbms.security.procedures.unrestricted": ["apoc.*"] ]
            ]

            versions.add(version)
        }
    }

    assertVersionsDidntShrink(previousVersions, versions)

    def versionsFile = new File("build/versions.json")
    versionsFile.write(JsonOutput.prettyPrint(JsonOutput.toJson(versions)))
}

// We have noticed in the past that the versions.json file sometimes gets wiped clean by the task when it's run in
// TeamCity. We assume that this is due to one or several of the HTTP requests this job makes fails silently. In these
// scenarios it is better to simply keep the old versions.json file. We detect this scenario by verifying the new
// versions have at least as many keys as the previous versions
static def assertVersionsDidntShrink(previousVersions, versions) {
    if (previousVersions.size() > versions.size()) throw new Exception("Error: versions file shrank.")
}

// TODO: Remove this once we begin signing APOC jars
// Calculates checksums of an APOC Jar. Skips downloading and hashing APOC versions it already knows about.
task checksums <<  {
    def apocReleases = apocReleases()
    def checksums = new JsonSlurper().parse(new File("checksums.json"))

    for (apocRelease in apocReleases) {
        def apocVersion = apocRelease.tag_name

        if (checksums.containsKey(apocVersion)) {
            println("skipping: " + apocVersion)
            continue
        }

        println("hashing: " + apocVersion)
        def assets = apocRelease.assets.find { it.browser_download_url.contains("apoc-${apocVersion}") }

        def fileName = "apoc-${apocVersion}-core.jar"
        def url = assets.browser_download_url
        def f = new File(fileName)

        if (!f.exists()) {
            new URL(url).withInputStream { i -> f.withOutputStream { it << i }}
        }

        println("sha1: " + Checksum.getSha1sum(f))
        println("sha256: " + Checksum.getSha256sum(f))
        println("md5: " + Checksum.getMD5sum(f))

        checksums[apocVersion] = [sha1: Checksum.getSha1sum(f), sha256: Checksum.getSha256sum(f), md5: Checksum.getMD5sum(f)]
    }

    def checksumsFile = new File("build/checksums.json")
    checksumsFile.write(JsonOutput.prettyPrint(JsonOutput.toJson(checksums)))
}

static def normalizeVersion(str) {
    return str.split("[.-]").collect { it =~ "^\\d+\$" ? it.padLeft(4,"0") : it }.join(".") + "/"
}

class Checksum {
    static getSha1sum(file) {
        return getChecksum(file, "SHA1")
    }

    static getSha256sum(file) {
        return getChecksum(file, "SHA-256")
    }

    static getMD5sum(file) {
        return getChecksum(file, "MD5")
    }

    static getChecksum(file, type) {
        def digest = MessageDigest.getInstance(type)
        def inputStream = file.newInputStream()
        def buffer = new byte[16384]
        def len

        while((len=inputStream.read(buffer)) > 0) {
            digest.update(buffer, 0, len)
        }
        def sha1sum = digest.digest()

        def result = ""
        for(byte b : sha1sum) {
            result += toHex(b)
        }
        return result
    }

    private static hexChr(int b) {
        return Integer.toHexString(b & 0xF)
    }

    private static toHex(int b) {
        return hexChr((b & 0xF0) >> 4) + hexChr(b & 0x0F)
    }
}
